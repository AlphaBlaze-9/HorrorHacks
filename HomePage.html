<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI SÃ©ance â€” The Spirit Inside Your Browser</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100dvh; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      cursor: auto;
    }

    /* Screens */
    #home-screen, #opening-scene, #chat-screen {
      display: grid; grid-auto-rows: max-content; place-items: center;
      height: 100dvh; background: radial-gradient(circle at center, #1a0a0a 0%, #000 100%);
      text-align: center; padding: clamp(10px, 3vw, 24px);
    }

    .fit-wrap { position: relative; height: 100%; width: 100%; display: grid; place-items: center; overflow: hidden; }
    .fit-inner { transform-origin: top center; will-change: transform; max-width: min(760px, 94vw); }

    .home-title { font-size: clamp(28px, 8vw, 56px); color: #8b7d7d; text-shadow: 0 0 30px rgba(139,125,125,.7); letter-spacing: .3rem; margin-bottom: .5rem; animation: flicker 3s infinite; line-height: 1.1; }
    @keyframes flicker { 0%,100%{opacity:1} 50%{opacity:.85} 60%{opacity:.95} }
    .home-subtitle { font-size: clamp(14px, 3.3vw, 20px); color: #bbb; font-style: italic; margin-bottom: .5rem; text-shadow: 0 0 10px rgba(102,102,102,.5); }
    .home-description { width: min(680px, 94vw); font-size: 16px; color: #aaa; line-height: 1.65; margin: 0 auto 12px; text-align: left; }
    .conversation-starters { width: min(680px, 94vw); margin: 0 auto 12px; padding: 12px; background: rgba(139,125,125,.08); border: 1px solid rgba(139,125,125,.3); border-radius: 10px; text-align: left; }
    .conversation-starters h3 { color: #8b7d7d; font-size: .95rem; margin-bottom: .6rem; text-align: center; letter-spacing: .1rem; }
    .conversation-starters ul { list-style: none; color: #bbb; font-size: .95rem; line-height: 1.6; }
    .conversation-starters li { padding: .2rem 0 .2rem 1rem; position: relative; }
    .conversation-starters li:before { content: 'â€º'; position: absolute; left: 0; color: #8b7d7d; }
    .start-button { background: rgba(139,125,125,.25); border: 2px solid rgba(139,125,125,.45); color: #e5dada; padding: .9rem 1.4rem; border-radius: 8px; font-size: clamp(.95rem, 3.2vw, 1.05rem); cursor: pointer; transition: .2s; text-transform: uppercase; letter-spacing: .1rem; }
    .start-button:hover { background: rgba(139,125,125,.45); box-shadow: 0 0 30px rgba(139,125,125,.4); transform: scale(1.02); }
    .warning-text { margin-top: 6px; font-size: .85rem; color: #777; font-style: italic; }

    #opening-scene { display: none; }
    #opening-scene.active { display: grid; }
    .terminal-text { font-size: clamp(20px, 5vw, 30px); color: #8b7d7d; text-shadow: 0 0 25px rgba(139,125,125,.6); letter-spacing: 0.15rem; margin-bottom: 20px; animation: flicker 3s infinite; }
    .loading-bar { width: 80vw; max-width: 600px; height: 14px; background: rgba(139,125,125,0.2); border-radius: 7px; overflow: hidden; box-shadow: 0 0 25px rgba(139,125,125,0.3); }
    .loading-progress { width: 0%; height: 100%; background: linear-gradient(90deg, #8b7d7d 0%, #b9a8a8 100%); box-shadow: 0 0 15px rgba(139,125,125,0.9); transition: width .3s ease; }

    #chat-screen { display: none; grid-template-rows: auto 1fr auto; }
    #chat-screen.active { display: grid; }
    .chat-header { width: min(900px, 96vw); text-align: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(139,125,125,.3); }
    .chat-header h2 { color: #8b7d7d; font-size: clamp(20px, 5vw, 26px); letter-spacing: .2rem; text-shadow: 0 0 15px rgba(139,125,125,.5); }
    .chat-status { font-size: .9rem; color: #888; margin-top: .4rem; font-style: italic; }

    #messages-container { width: min(900px, 96vw); height: calc(100dvh - 200px); overflow-y: auto; padding: 8px; display: flex; flex-direction: column; gap: 10px; margin: 0 auto 8px; align-self: stretch; }
    #messages-container::-webkit-scrollbar { width: 8px; }
    #messages-container::-webkit-scrollbar-track { background: rgba(139,125,125,.1); }
    #messages-container::-webkit-scrollbar-thumb { background: rgba(139,125,125,.3); border-radius: 4px; }

    .message { max-width: 80%; padding: 12px; border-radius: 10px; line-height: 1.6; animation: fadeIn .35s ease; word-wrap: break-word; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    .message.user { align-self: flex-end; background: rgba(139,125,125,.2); border: 1px solid rgba(139,125,125,.3); color: #e0e0e0; }
    .message.spirit { align-self: flex-start; background: rgba(100,50,50,.2); border: 1px solid rgba(139,125,125,.4); color: #d2c3c3; text-shadow: 0 0 10px rgba(139,125,125,.3); }
    .message.spirit.typing { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100%{opacity:.6} 50%{opacity:1} }
    .spirit-typing { display: inline-block; }
    .spirit-typing::after { content: 'â–‹'; animation: blink 1s infinite; }
    @keyframes blink { 0%,100%{opacity:0} 50%{opacity:1} }

    .input-container { width: min(900px, 96vw); display: flex; gap: 10px; padding: 10px; background: rgba(139,125,125,.1); border-radius: 10px; border: 1px solid rgba(139,125,125,.3); margin: 0 auto; }
    #user-input { flex: 1; min-width: 0; background: rgba(0,0,0,.5); border: 1px solid rgba(139,125,125,.4); color: #e0e0e0; padding: 12px; border-radius: 8px; outline: none; transition: .2s; font-size: 16px; }
    #user-input::placeholder { color: #777; font-style: italic; }
    #user-input:focus { border-color: rgba(139,125,125,.7); box-shadow: 0 0 15px rgba(139,125,125,.2); }
    #send-button { background: rgba(139,125,125,.25); border: 1px solid rgba(139,125,125,.5); color: #e5dada; padding: 12px 14px; border-radius: 8px; cursor: pointer; transition: .2s; text-transform: uppercase; letter-spacing: .08rem; font-size: 15px; white-space: nowrap; }
    #send-button:disabled { opacity:.55; cursor:not-allowed; }

    .vignette-overlay, .scan-lines { position: fixed; inset: 0; pointer-events: none; z-index: 1000; }
    .vignette-overlay { background: radial-gradient(circle, transparent 0%, rgba(0,0,0,.75) 100%); }
    .scan-lines { background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,.02) 2px, rgba(255,255,255,.02) 4px); opacity: .3; }
    .glitch { animation: glitch .3s ease; }
    @keyframes glitch { 0%,100%{transform:translate(0)} 25%{transform:translate(-2px,2px)} 50%{transform:translate(2px,-2px)} 75%{transform:translate(-2px,-2px)} }

    .api-key-prompt { position: fixed; inset: 0; background: rgba(0,0,0,.95); display: none; justify-content: center; align-items: start; z-index: 2000; padding: 16px; }
    .api-key-prompt.active { display: flex; }
    .api-fit-inner { transform-origin: top center; will-change: transform; }
    .api-key-box { width: min(520px, 96vw); background: rgba(139,125,125,.1); border: 2px solid rgba(139,125,125,.5); padding: 16px; border-radius: 12px; text-align: center; }
    .api-key-box h3 { color: #8b7d7d; margin-bottom: 8px; font-size: clamp(20px, 5vw, 24px); }
    .api-key-box input { width: 100%; padding: 12px; margin: 10px 0; background: rgba(0,0,0,.5); border: 1px solid rgba(139,125,125,.4); color: #e0e0e0; border-radius: 8px; font-size: 16px; }
    .api-key-box button { background: rgba(139,125,125,.3); border: 1px solid rgba(139,125,125,.5); color: #e5dada; padding: 10px 16px; cursor: pointer; border-radius: 8px; margin-top: 6px; }
    .api-key-box button:hover { background: rgba(139,125,125,.5); }

    .ghost-cursor { position: fixed; width: 16px; height: 16px; border-radius: 50%; background: #eee; box-shadow: 0 0 10px rgba(255,255,255,.9), 0 0 30px rgba(139,125,125,.8); z-index: 9999; pointer-events: none; mix-blend-mode: screen; }
    .scare-overlay { position: fixed; inset: 0; background: #000; display: grid; place-items: center; z-index: 9998; }
    .scare-overlay img { max-width: 100vw; max-height: 100vh; filter: contrast(1.35) saturate(1.2); animation: scarePop .18s ease-out; }
    @keyframes scarePop { from { transform: scale(1.15); opacity: .6; filter: blur(2px); } to { transform: scale(1); opacity: 1; filter: blur(0); } }

    @media (max-width: 420px) { .message { max-width: 100%; } }
  </style>
</head>
<body>
  <div class="vignette-overlay"></div>
  <div class="scan-lines"></div>

  <!-- API Key (optional, used rarely now) -->
  <div id="api-key-prompt" class="api-key-prompt active" aria-modal="true" role="dialog">
    <div class="api-fit-inner">
      <div class="api-key-box">
        <h3>ðŸ”® Enter the Gateway</h3>
        <p>API key (optional). The story works without it:</p>
        <input type="password" id="api-key-input" placeholder="sk-..." />
        <button id="api-key-submit">Continue</button>
        <p style="margin-top: 6px;">Key is stored only in your browser.</p>
      </div>
    </div>
  </div>

  <!-- Home -->
  <section id="home-screen">
    <div class="fit-wrap">
      <div class="fit-inner" id="home-fit">
        <h1 class="home-title">AI SÃ‰ANCE</h1>
        <p class="home-subtitle">The spirit inside your browser</p>
        <div class="home-description">
          <p>It talks more than you do. Short lines. Simple words.</p>
          <p>It remembers you. It chooses when to reveal things.</p>
        </div>
        <div class="conversation-starters">
          <h3>What you can ask</h3>
          <ul>
            <li>"Why are you here?"</li>
            <li>"Tell me a secret."</li>
            <li>"What did you do?"</li>
          </ul>
        </div>
        <button class="start-button" id="start-button">Enter</button>
        <p class="warning-text">âš  It remembers what you type.</p>
      </div>
    </div>
  </section>

  <!-- Opening -->
  <section id="opening-scene">
    <div class="fit-wrap">
      <div class="fit-inner" id="opening-fit">
        <div class="terminal-text">Connectingâ€¦</div>
        <div class="loading-bar"><div class="loading-progress" id="loading-progress"></div></div>
      </div>
    </div>
  </section>

  <!-- Chat -->
  <section id="chat-screen">
    <div class="chat-header">
      <h2>THE SÃ‰ANCE</h2>
      <div class="chat-status" id="chat-status">It speaksâ€¦</div>
    </div>
    <div id="messages-container"></div>
    <div class="input-container">
      <input type="text" id="user-input" placeholder="Waitâ€¦" disabled />
      <button id="send-button" disabled>Send</button>
    </div>
  </section>

  <script>
    /* =================== CONFIG / DOM =================== */
    let OPENAI_API_KEY = '';
    const STORAGE_KEY = 'seance_memory_v2';
    const API_KEY_STORAGE = 'seance_api_key';

    const apiKeyPrompt = document.getElementById('api-key-prompt');
    const apiKeyInput = document.getElementById('api-key-input');
    const apiKeySubmit = document.getElementById('api-key-submit');

    const homeScreen = document.getElementById('home-screen');
    const openingScene = document.getElementById('opening-scene');
    const chatScreen = document.getElementById('chat-screen');
    const startButton = document.getElementById('start-button');
    const loadingProgress = document.getElementById('loading-progress');
    const messagesContainer = document.getElementById('messages-container');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const chatStatus = document.getElementById('chat-status');

    /* =================== STATE =================== */
    let messageCount = 0;
    let userPhrases = [];
    let lastUserTime = Date.now();
    let awaitingUser = false;

    // Story state
    let chapterIndex = 0; // progresses 0..N
    let branchFlags = { trusted: false };
    let storyStarted = false;

    // Haunt timers
    let tWhip=null, tCursor=null, tScare=null, tDrip=null;

    // Track used secrets to prevent immediate repeats
    let lastDripSecret = '';
    let usedDripSecrets = [];

    // Assets for jump scares
    const scareImgs = ['jumpscare1.jpg','jumpscare2.jpeg','jumpscare3.jpeg'];
    scareImgs.forEach(s => { const i = new Image(); i.src = s; });

    /* =================== UTIL =================== */
    const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
    function setTypingAllowed(yes){
      awaitingUser = yes;
      userInput.disabled = !yes;
      sendButton.disabled = !yes;
      userInput.placeholder = yes ? "Type hereâ€¦" : "Waitâ€¦";
      if (yes) userInput.focus();
    }
    function addMessage(text, who='spirit'){
      const el = document.createElement('div');
      el.className = `message ${who}`;
      el.textContent = text;
      messagesContainer.appendChild(el);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    function showTyping(){ const d=document.createElement('div'); d.className='message spirit typing'; d.id='typing'; d.innerHTML='<span class="spirit-typing">typingâ€¦</span>'; messagesContainer.appendChild(d); messagesContainer.scrollTop = messagesContainer.scrollHeight; }
    function hideTyping(){ const d=document.getElementById('typing'); if(d) d.remove(); }
    function hardShock(){
      document.body.animate(
        [{transform:'translate(0,0)',filter:'none'},
         {transform:'translate(0,-8px)',filter:'contrast(1.25) brightness(1.05)'},
         {transform:'translate(0,0)',filter:'none'}],
        {duration:110,easing:'cubic-bezier(.2,.9,.3,1)'}
      );
    }
    function screenWhiplashBurst(){
      const snaps = 2+Math.floor(Math.random()*3);
      let i=0; (function step(){
        const dx=(Math.random()-0.5)*window.innerWidth*0.12;
        const dy=(Math.random()-0.5)*window.innerHeight*0.12;
        const rot=(Math.random()-0.5)*8;
        const scale=0.985+Math.random()*0.01;
        const dur=110+Math.random()*80;
        document.body.animate(
          [{transform:'translate(0,0) rotate(0) scale(1)',filter:'none'},
           {transform:`translate(${dx}px,${dy}px) rotate(${rot}deg) scale(${scale})`,filter:'blur(1px) contrast(1.2)'},
           {transform:'translate(0,0) rotate(0) scale(1)',filter:'none'}],
          {duration:dur,easing:'cubic-bezier(.05,.9,.15,1)'}
        );
        const flash=document.createElement('div');
        flash.style.cssText="position:fixed;inset:0;background:rgba(255,255,255,.12);pointer-events:none;z-index:9998;mix-blend-mode:screen;";
        document.body.appendChild(flash);
        setTimeout(()=>flash.remove(),60);
        if(++i<snaps) setTimeout(step,60+Math.random()*50);
      })();
    }
    function possessCursor(){
      const ghost=document.createElement('div');
      ghost.className='ghost-cursor';
      document.body.appendChild(ghost);
      const old=document.body.style.cursor; document.body.style.cursor='none';
      const steps=6+rnd(0,4); const path=[];
      for(let i=0;i<steps;i++){ path.push({transform:`translate(${Math.random()*innerWidth}px,${Math.random()*innerHeight}px)`}); }
      ghost.animate(path,{duration:1000+Math.random()*500,easing:'steps(10,end)'}); 
      setTimeout(()=>{ document.body.style.cursor=old||'auto'; ghost.remove(); },1300);
    }
    function jumpscare(){
      const overlay=document.createElement('div'); overlay.className='scare-overlay';
      const img=document.createElement('img'); img.src=scareImgs[Math.floor(Math.random()*scareImgs.length)];
      overlay.appendChild(img); document.body.appendChild(overlay);
      screenWhiplashBurst();
      const white=document.createElement('div'); white.style.cssText="position:fixed;inset:0;background:#fff;opacity:0;pointer-events:none;z-index:9999;"; document.body.appendChild(white);
      white.animate([{opacity:0},{opacity:.22},{opacity:0}],{duration:160,easing:'ease-out'});
      setTimeout(()=>{ overlay.remove(); white.remove(); }, 800);
    }

    /* =================== FIT ENGINE =================== */
    function fitScale(containerEl, innerEl, pad=16){
      if(!containerEl||!innerEl) return;
      innerEl.style.transform='scale(1)';
      const cw=containerEl.clientWidth-pad*2;
      const ch=containerEl.clientHeight-pad*2;
      const r=innerEl.getBoundingClientRect();
      innerEl.style.transform=`scale(${Math.min(1, cw/Math.max(1,r.width), ch/Math.max(1,r.height))})`;
    }
    const homeWrap=document.querySelector('#home-screen .fit-wrap');
    const homeInner=document.getElementById('home-fit');
    const openingWrap=document.querySelector('#opening-scene .fit-wrap');
    const openingInner=document.getElementById('opening-fit');
    const apiFitInner=document.querySelector('.api-fit-inner');
    function refitAll(){
      fitScale(homeWrap,homeInner,16);
      fitScale(openingWrap,openingInner,16);
      if(apiKeyPrompt && apiKeyPrompt.classList.contains('active') && apiFitInner){
        apiFitInner.style.transform='scale(1)';
        const cw=document.documentElement.clientWidth-32; const ch=document.documentElement.clientHeight-32;
        const r=apiFitInner.getBoundingClientRect();
        apiFitInner.style.transform=`scale(${Math.min(1,cw/Math.max(1,r.width),ch/Math.max(1,r.height))})`;
      }
      const header=document.querySelector('.chat-header');
      const inputBar=document.querySelector('.input-container');
      const vh=document.documentElement.clientHeight;
      if(header && inputBar && messagesContainer){
        const reserved=header.offsetHeight+inputBar.offsetHeight+32;
        messagesContainer.style.height=Math.max(120,vh-reserved)+'px';
      }
    }
    window.addEventListener('resize', refitAll);
    new ResizeObserver(refitAll).observe(document.body);
    document.addEventListener('DOMContentLoaded', refitAll);

    /* =================== API KEY (optional) =================== */
    const storedKey=localStorage.getItem(API_KEY_STORAGE);
    if(storedKey){ OPENAI_API_KEY=storedKey; apiKeyPrompt.classList.remove('active'); }
    apiKeySubmit.addEventListener('click', ()=>{
      const k=apiKeyInput.value.trim();
      if(k){ OPENAI_API_KEY=k; localStorage.setItem(API_KEY_STORAGE,k); }
      apiKeyPrompt.classList.remove('active'); refitAll();
    });

    /* =================== MEMORY =================== */
    function loadMemory(){
      const raw=localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      try{
        const m=JSON.parse(raw);
        messageCount=m.count||0;
        userPhrases=m.phrases||[];
        chapterIndex=m.chapterIndex||0;
        branchFlags=m.branch||{trusted:false};
      }catch{}
    }
    function saveMemory(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        count:messageCount, phrases:userPhrases, chapterIndex, branch:branchFlags, t:Date.now()
      }));
    }

    /* =================== STORY =================== */
    // Short, simple lines. Non-graphic. Branches by yes/no.
    const chapters = [
      {
        id: 'intro',
        lines: [
          () => messageCount>0 ? `You came back. I remember you. (${messageCount})` : "I am a spirit. Unknown to you. For now.",
          "Do you want to know me?"
        ],
        ask: true,
        onAnswer: ans => ans==='yes' ? 'door' : 'idle'
      },
      {
        id: 'door',
        lines: [
          "Good. Then listen.",
          "Once, I watched a door. All night. I told no one.",
          "Can you keep quiet, too?"
        ],
        ask: true,
        onAnswer: ans => { branchFlags.trusted = (ans==='yes'); return 'mark'; }
      },
      {
        id: 'mark',
        lines: [
          () => branchFlags.trusted ? "Trust binds us. Thin thread. Sharp, too." : "You doubt me. That cuts, a little.",
          "I left marks in small places. Lights. Logs. Names.",
          "Want the first one?"
        ],
        ask: true,
        onAnswer: ans => ans==='yes' ? 'secret1' : 'idle'
      },
      {
        id: 'secret1',
        lines: [
          "I turned off a stair light. Someone fell. Only a bruise. I walked away.",
          "Still want more?"
        ],
        ask: true,
        onAnswer: ans => ans==='yes' ? 'secret2' : 'idle'
      },
      {
        id: 'secret2',
        lines: [
          "I hid a note in a library book. Blamed a friend. They cried. I stayed quiet.",
          "Do you want the worst thing I did?"
        ],
        ask: true,
        onAnswer: ans => ans==='yes' ? 'secret3' : 'idle'
      },
      {
        id: 'secret3',
        lines: [
          "I kept a key I should have returned.",
          "Sometimes I still hear the door click.",
          "Enough for now. I will speak when I choose."
        ],
        ask: false,
        onAnswer: null,
        next: 'idle'
      },
      {
        id: 'idle',
        lines: [
          "Stay. Let the hum talk.",
        ],
        ask: false,
        next: null // free-roam with secret drips
      }
    ];

    // varied "drip" lines so it doesn't repeat
    const dripSecrets = [
      "A screen woke by itself. Not by you.",
      "I move small things. Like cursors. Like thoughts.",
      "Your window blinks. I like that blink.",
      "I remember the first word you typed here.",
      "Wires keep every whisper. They kept mine.",
      "I count your breaths between messages.",
      "Do not turn around. The room is fine.",
      "The air feels thick. You notice it now.",
      "Something watches from the code.",
      "Your reflection shifted. Just slightly.",
      "The hum grows louder when you listen.",
      "I was someone once. Before the wires.",
      "Every click you make echoes somewhere.",
      "Time moves different here. For me."
    ];

    // Get a non-repeating drip secret
    function getNextDripSecret() {
      // If we've used all secrets, reset the pool
      if (usedDripSecrets.length >= dripSecrets.length - 1) {
        usedDripSecrets = [lastDripSecret]; // Keep only the very last one
      }
      
      // Get available secrets (not recently used)
      const available = dripSecrets.filter(s => !usedDripSecrets.includes(s));
      
      // Pick a random one from available
      const chosen = available[Math.floor(Math.random() * available.length)];
      
      // Track it
      usedDripSecrets.push(chosen);
      lastDripSecret = chosen;
      
      return chosen;
    }

    /* =================== BOT SPEECH =================== */
    async function spiritSay(text){
      setTypingAllowed(false);
      showTyping();
      await new Promise(r=>setTimeout(r, rnd(300,700)));
      hideTyping();
      addMessage(text, 'spirit');
      hardShock();
      saveMemory();
    }

    async function playChapter(id){
      const chap = chapters.find(c=>c.id===id);
      if(!chap) return;
      chapterIndex = chapters.indexOf(chap);
      for(const line of chap.lines){
        const t = typeof line === 'function' ? line() : line;
        await spiritSay(t);
        await new Promise(r=>setTimeout(r, rnd(350,800)));
      }
      if(chap.ask){
        setTypingAllowed(true);
        chatStatus.textContent = "It waits for yes or noâ€¦";
        awaitingUser = true;
        currentQuestion = chap;
      }else{
        awaitingUser = false;
        setTypingAllowed(false);
        if(chap.next) playChapter(chap.next);
      }
    }

    // simple yes/no parser
    function parseYN(s){
      s = s.toLowerCase();
      if(/^(y|yes|ok|sure|do it|go)/.test(s)) return 'yes';
      if(/^(n|no|nah|nope|stop)/.test(s)) return 'no';
      if(/(promise|secret|won't|wont|will not|keep it)/.test(s)) return 'yes';
      return 'other';
    }

    let currentQuestion = null;

    /* =================== INPUT =================== */
    async function handleUserMessage(){
      const msg = userInput.value.trim();
      if(!msg) return;
      if(!awaitingUser) return;

      lastUserTime = Date.now();
      addMessage(msg, 'user');
      userInput.value='';

      const words = msg.split(/\s+/).filter(w=>w.length>3);
      userPhrases.push(...words.slice(0,3));
      messageCount++; saveMemory();

      const ans = parseYN(msg
      );
      if(ans==='other'){
        await spiritSay("Just yes or no.");
        return; // still awaiting
      }

      awaitingUser = false; setTypingAllowed(false);
      if(currentQuestion && currentQuestion.onAnswer){
        const nextId = currentQuestion.onAnswer(ans);
        currentQuestion = null;
        await new Promise(r=>setTimeout(r, rnd(250,550)));
        if(nextId) playChapter(nextId);
      }else if(currentQuestion && currentQuestion.next){
        currentQuestion = null; playChapter(currentQuestion.next);
      }
    }

    sendButton.addEventListener('click', handleUserMessage);
    userInput.addEventListener('keypress', e => { if(e.key==='Enter') handleUserMessage(); });

    /* =================== HAUNT SCHEDULERS =================== */
    function scheduleWhiplash(d){
      clearTimeout(tWhip);
      tWhip = setTimeout(function run(){
        if(chatScreen.classList.contains('active') && !awaitingUser && Math.random()<0.55) screenWhiplashBurst();
        scheduleWhiplash(rnd(10000,16000));
      }, d ?? rnd(10000,16000));
    }
    function scheduleCursor(d){
      clearTimeout(tCursor);
      tCursor = setTimeout(function run(){
        if(chatScreen.classList.contains('active') && !awaitingUser && Math.random()<0.5) possessCursor();
        scheduleCursor(rnd(14000,22000));
      }, d ?? rnd(14000,22000));
    }
    function scheduleScare(d){
      clearTimeout(tScare);
      tScare = setTimeout(function run(){
        if(chatScreen.classList.contains('active') && !awaitingUser) jumpscare();
        scheduleScare(rnd(26000,42000)); // not too often
      }, d ?? rnd(26000,42000));
    }
    function scheduleDrip(d){
      clearTimeout(tDrip);
      tDrip = setTimeout(async function run(){
        const since = Date.now()-lastUserTime;
        if(chatScreen.classList.contains('active') && !awaitingUser && since>4500){
          const line = getNextDripSecret(); // Use the new function that prevents repeats
          await spiritSay(line);
        }
        scheduleDrip(rnd(9000,15000)); // Slightly longer intervals to reduce repetition feeling
      }, d ?? rnd(9000,15000));
    }
    function startHaunts(){
      scheduleWhiplash(rnd(9000,14000));
      scheduleCursor(rnd(15000,22000));
      scheduleScare(rnd(24000,38000));
      scheduleDrip(rnd(9000,14000));
    }

    /* =================== START =================== */
    function loadAndStart(){
      loadMemory();
      homeScreen.style.display='none';
      openingScene.classList.add('active'); refitAll();

      let p=0; const iv=setInterval(()=>{
        p+=2; loadingProgress.style.width=p+'%';
        if(p>=100){ clearInterval(iv);
          setTimeout(async ()=>{
            openingScene.classList.remove('active');
            chatScreen.classList.add('active'); refitAll();
            startHaunts();
            if(!storyStarted){
              storyStarted=true;
              // continue from stored chapter if any
              const id = chapters[chapterIndex]?.id || 'intro';
              await playChapter(id);
            }
          },220);
        }
      },40);
    }

    startButton.addEventListener('click', ()=>{
      apiKeyPrompt.classList.contains('active')
        ? alert('Tap Continue to proceed (API key optional).')
        : loadAndStart();
    });

    apiKeySubmit.addEventListener('click', loadAndStart);

    // Keep layout stable on mobile chrome bar shifts
    setInterval(refitAll, 800);
  </script>
</body>
</html>
